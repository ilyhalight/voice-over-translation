import type { VideoHandler } from "../../index";
import { localizationProvider } from "../../localization/localizationProvider";
import { SubtitlesProcessor } from "../../subtitles/processor";
import type { SubtitleDescriptor } from "../../subtitles/types";
import debug from "../../utils/debug";
import { proxifyYandexSubtitlesUrl } from "./proxyShared";

type IndexedSubtitleDescriptor = {
  descriptor: SubtitleDescriptor;
  index: number;
};

type SubtitlesSelectOption = {
  label: string;
  value: string;
  selected: boolean;
  disabled: boolean;
};

const VALID_SUBTITLE_FORMATS = new Set<SubtitleDescriptor["format"]>([
  "srt",
  "vtt",
  "json",
]);

function asSubtitleDescriptor(value: unknown): SubtitleDescriptor | null {
  if (!value || typeof value !== "object") {
    return null;
  }

  const descriptor = value as Partial<SubtitleDescriptor>;
  if (
    typeof descriptor.source !== "string" ||
    typeof descriptor.language !== "string" ||
    typeof descriptor.url !== "string" ||
    typeof descriptor.format !== "string" ||
    !VALID_SUBTITLE_FORMATS.has(
      descriptor.format as SubtitleDescriptor["format"],
    )
  ) {
    return null;
  }

  return {
    source: descriptor.source,
    format: descriptor.format as SubtitleDescriptor["format"],
    language: descriptor.language,
    url: descriptor.url,
    translatedFromLanguage:
      typeof descriptor.translatedFromLanguage === "string"
        ? descriptor.translatedFromLanguage
        : undefined,
    isAutoGenerated:
      typeof descriptor.isAutoGenerated === "boolean"
        ? descriptor.isAutoGenerated
        : undefined,
  };
}

function getIndexedSubtitleDescriptors(
  subtitles: unknown[],
): IndexedSubtitleDescriptor[] {
  const descriptors: IndexedSubtitleDescriptor[] = [];

  for (let index = 0; index < subtitles.length; index += 1) {
    const descriptor = asSubtitleDescriptor(subtitles[index]);
    if (!descriptor) {
      continue;
    }

    descriptors.push({
      descriptor,
      index,
    });
  }

  return descriptors;
}

function findSubtitleDescriptorByIndex(
  subtitles: unknown[],
  index: number,
): SubtitleDescriptor | null {
  return (
    getIndexedSubtitleDescriptors(subtitles).find(
      (item) => item.index === index,
    )?.descriptor ?? null
  );
}

function createDisabledSubtitlesOption(): SubtitlesSelectOption {
  return {
    label: localizationProvider.get("VOTSubtitlesDisabled"),
    value: "disabled",
    selected: true,
    disabled: false,
  };
}

function getSelectedSubtitlesValue(
  selectedValues: Iterable<string>,
): string | undefined {
  return selectedValues[Symbol.iterator]().next().value;
}

function buildSubtitleLabel(subtitle: SubtitleDescriptor): string {
  const languageLabel = localizationProvider.getLangLabel(subtitle.language);
  const translatedFromLabel = subtitle.translatedFromLanguage
    ? ` ${localizationProvider.get("VOTTranslatedFrom")} ${localizationProvider.getLangLabel(
        subtitle.translatedFromLanguage,
      )}`
    : "";
  const sourceSuffix =
    subtitle.source === "yandex" ? "" : `, ${globalThis.location.hostname}`;
  const autogeneratedSuffix = subtitle.isAutoGenerated
    ? ` (${localizationProvider.get("VOTAutogenerated")})`
    : "";

  return `${languageLabel}${translatedFromLabel}${sourceSuffix}${autogeneratedSuffix}`;
}

function normalizeLang(lang?: string): string {
  return (lang ?? "").toLowerCase();
}

function baseLang(lang?: string): string {
  const normalized = normalizeLang(lang);
  // Match both BCP-47 styles (en-US) and underscore styles (en_US)
  return normalized.split(/[-_]/)[0];
}

function langMatches(candidate?: string, desired?: string): boolean {
  if (!candidate || !desired) return false;
  const cand = normalizeLang(candidate);
  const want = normalizeLang(desired);
  return cand === want || baseLang(cand) === baseLang(want);
}

/**
 * Picks the best subtitles track for the current (from -> to) language pair.
 *
 * Priority:
 * 1) Yandex subtitles for the exact language pair
 * 2) (Special case when from == to) native subtitles, then site subtitles
 *    for the target language, and only then Yandex target-language subtitles
 * 3) Yandex subtitles for the target language
 * 4) Other providers for the exact language pair
 * 5) Other providers for the target language (prefer non-autogenerated)
 *
 * If target-language subtitles are unavailable, returns null (show nothing).
 */
function pickBestSubtitlesIndex(
  subtitles: IndexedSubtitleDescriptor[],
  fromLang: string,
  toLang: string,
): number | null {
  if (!subtitles.length) return null;

  const from = normalizeLang(fromLang);
  const to = normalizeLang(toLang);
  const fromIsAuto = from === "auto" || from === "";

  const fromBase = baseLang(from);
  const toBase = baseLang(to);

  const isYandex = (s: SubtitleDescriptor) => s.source === "yandex";
  const isAutoGenerated = (s: SubtitleDescriptor) => Boolean(s.isAutoGenerated);
  const matchesPair = (
    s: SubtitleDescriptor,
    wantFrom: string,
    wantTo: string,
  ) => {
    if (!langMatches(s.language, wantTo)) return false;
    if (fromIsAuto) return true;
    return langMatches(s.translatedFromLanguage, wantFrom);
  };

  const isSameLangOriginal = (s: SubtitleDescriptor, lang: string) => {
    if (!langMatches(s.language, lang)) return false;
    // Prefer native captions when source and target language are the same.
    if (!s.translatedFromLanguage) return true;
    return langMatches(s.translatedFromLanguage, lang);
  };

  const find = (predicate: (s: SubtitleDescriptor) => boolean) =>
    subtitles.find(({ descriptor }) => predicate(descriptor))?.index ?? null;
  const findOtherTarget = (): number | null => {
    const otherTargetManual = find(
      (s) => !isYandex(s) && langMatches(s.language, to) && !isAutoGenerated(s),
    );
    if (otherTargetManual != null) return otherTargetManual;

    return find(
      (s) => !isYandex(s) && langMatches(s.language, to) && isAutoGenerated(s),
    );
  };

  // 1) Yandex exact pair
  const yandexPair = find((s) => isYandex(s) && matchesPair(s, from, to));
  if (yandexPair != null) return yandexPair;

  // Special-case: when the video language and target language are the same,
  // prefer native subtitles in that language over subtitles translated from a
  // different source language.
  if (!fromIsAuto && fromBase && toBase && fromBase === toBase) {
    const nativeManual = find(
      (s) => isSameLangOriginal(s, to) && !isAutoGenerated(s),
    );
    if (nativeManual != null) return nativeManual;

    const nativeAuto = find(
      (s) => isSameLangOriginal(s, to) && isAutoGenerated(s),
    );
    if (nativeAuto != null) return nativeAuto;

    // For same-language captions, prefer platform captions over Yandex
    // auto-translations (e.g. pick site "PL -> RU" before Yandex "EN -> RU").
    const otherTarget = findOtherTarget();
    if (otherTarget != null) return otherTarget;

    const yandexTargetSameLang = find(
      (s) => isYandex(s) && langMatches(s.language, to),
    );
    if (yandexTargetSameLang != null) return yandexTargetSameLang;
  }

  // 2) Yandex target language
  const yandexTarget = find((s) => isYandex(s) && langMatches(s.language, to));
  if (yandexTarget != null) return yandexTarget;

  // 3) Other providers exact pair
  const otherPair = find((s) => !isYandex(s) && matchesPair(s, from, to));
  if (otherPair != null) return otherPair;

  // 4) Other providers target language, prefer non-autogenerated
  const otherTarget = findOtherTarget();
  if (otherTarget != null) return otherTarget;

  return null;
}

export async function changeSubtitlesLang(
  this: VideoHandler,
  subs: string,
): Promise<VideoHandler> {
  debug.log("[onchange] subtitles", subs);
  const overlayView = this.uiManager.votOverlayView;
  if (!overlayView?.subtitlesSelect || !overlayView.downloadSubtitlesButton) {
    return this;
  }
  overlayView.subtitlesSelect.setSelectedValue(subs);
  if (subs === "disabled") {
    if (this.hasSubtitlesWidget()) {
      this.subtitlesWidget?.setContent(null);
    }
    overlayView.downloadSubtitlesButton.hidden = true;
    this.yandexSubtitles = null;
    return this;
  }

  const subtitlesIndex = Number.parseInt(subs, 10);
  const descriptor = findSubtitleDescriptorByIndex(
    this.subtitles,
    subtitlesIndex,
  );
  if (!descriptor) {
    overlayView.downloadSubtitlesButton.hidden = true;
    this.yandexSubtitles = null;
    return this;
  }

  let subtitlesObj: SubtitleDescriptor = { ...descriptor };
  const proxiedSubtitlesUrl = proxifyYandexSubtitlesUrl(subtitlesObj.url, {
    translateProxyEnabled: this.data?.translateProxyEnabled,
    proxyWorkerHost: this.data?.proxyWorkerHost,
  });
  if (proxiedSubtitlesUrl !== subtitlesObj.url) {
    subtitlesObj = {
      ...subtitlesObj,
      url: proxiedSubtitlesUrl,
    };
    debug.log(`[VOT] Subs proxied via ${subtitlesObj.url}`);
  }

  this.yandexSubtitles = await SubtitlesProcessor.fetchSubtitles(subtitlesObj);
  this.getSubtitlesWidget().setContent(
    this.yandexSubtitles,
    subtitlesObj.language,
  );
  overlayView.downloadSubtitlesButton.hidden = false;
  return this;
}

export async function updateSubtitlesLangSelect(this: VideoHandler) {
  const overlayView = this.uiManager.votOverlayView;
  if (!overlayView?.subtitlesSelect) {
    return;
  }

  const subtitleDescriptors = getIndexedSubtitleDescriptors(this.subtitles);
  if (subtitleDescriptors.length === 0) {
    const updatedOptions: SubtitlesSelectOption[] = [
      createDisabledSubtitlesOption(),
    ];
    overlayView.subtitlesSelect.updateItems(updatedOptions);
    await this.changeSubtitlesLang(updatedOptions[0].value);
    return;
  }

  const updatedOptions: SubtitlesSelectOption[] = [
    createDisabledSubtitlesOption(),
    ...subtitleDescriptors.map(({ descriptor, index }) => ({
      label: buildSubtitleLabel(descriptor),
      value: String(index),
      selected: false,
      disabled: false,
    })),
  ];
  overlayView.subtitlesSelect.updateItems(updatedOptions);
  await this.changeSubtitlesLang(updatedOptions[0].value);
}

/**
 * Hotkey/helper: enables subtitles for the currently selected language pair.
 *
 * If an exact "from -> to" subtitles track is unavailable, falls back to any
 * subtitles track in the target language.
 * For same-language pair (from == to), prefer site subtitles before Yandex.
 */
export async function enableSubtitlesForCurrentLangPair(this: VideoHandler) {
  const overlayView = this.uiManager.votOverlayView;
  if (!overlayView?.subtitlesSelect) return this;

  // Ensure we have subtitles list loaded.
  if (!Array.isArray(this.subtitles) || this.subtitles.length === 0) {
    try {
      await this.loadSubtitles();
    } catch {
      // If loading fails, we can't enable anything.
      return this;
    }
  }

  const fromLang = (this.videoData?.detectedLanguage ??
    this.translateFromLang) as string;
  const toLang = (this.videoData?.responseLanguage ??
    this.translateToLang) as string;

  const bestIdx = pickBestSubtitlesIndex(
    getIndexedSubtitleDescriptors(this.subtitles),
    fromLang,
    toLang,
  );
  if (bestIdx == null) {
    return this;
  }

  // If the currently selected subtitles already match the chosen track, do nothing.
  const currentValue = getSelectedSubtitlesValue(
    overlayView.subtitlesSelect.selectedValues,
  );
  if (currentValue === String(bestIdx)) {
    return this;
  }

  await this.changeSubtitlesLang(String(bestIdx));
  return this;
}

/**
 * Hotkey helper: toggles subtitles.
 *
 * - If subtitles are currently enabled (any non-"disabled" value), disable them.
 * - If subtitles are disabled, enable the best subtitles for the current
 *   language pair.
 */
export async function toggleSubtitlesForCurrentLangPair(this: VideoHandler) {
  const overlayView = this.uiManager.votOverlayView;
  if (!overlayView?.subtitlesSelect) return this;

  const currentValue = getSelectedSubtitlesValue(
    overlayView.subtitlesSelect.selectedValues,
  );

  if (currentValue && currentValue !== "disabled") {
    await this.changeSubtitlesLang("disabled");
    return this;
  }

  await this.enableSubtitlesForCurrentLangPair();
  return this;
}

export async function loadSubtitles(this: VideoHandler) {
  if (!this.videoData?.videoId) {
    console.error(
      `[VOT] ${localizationProvider.getDefault("VOTNoVideoIDFound")}`,
    );
    this.subtitles = [];
    return;
  }
  const cacheKey = this.getSubtitlesCacheKey(
    this.videoData.videoId,
    this.videoData.detectedLanguage,
    this.videoData.responseLanguage,
  );
  try {
    let cachedSubs = this.cacheManager.getSubtitles(cacheKey);
    if (!cachedSubs) {
      // Deduplicate concurrent requests for the same key (e.g. when user spams
      // the subtitles hotkey before the first request resolves).
      let inflight = this.subtitlesLoadPromises.get(cacheKey);
      if (inflight === undefined) {
        inflight = SubtitlesProcessor.getSubtitles(
          this.votClient,
          this.videoData,
        );
        this.subtitlesLoadPromises.set(cacheKey, inflight);
      }

      try {
        cachedSubs = await inflight;
        this.cacheManager.setSubtitles(cacheKey, cachedSubs);
      } finally {
        // Only clear if we're still pointing at the same promise.
        if (this.subtitlesLoadPromises.get(cacheKey) === inflight) {
          this.subtitlesLoadPromises.delete(cacheKey);
        }
      }
    }
    this.subtitles = cachedSubs;
  } catch (error) {
    console.error("[VOT] Failed to load subtitles:", error);
    this.subtitles = [];
  }
  await this.updateSubtitlesLangSelect();
}
